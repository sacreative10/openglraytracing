#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

#define INF 1e30

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}
float rand(float x) {
    return fract(sin(x) * 43758.5453);
}


float clamp(float x, float a, float b) {
    if(x < a) return a;
    if(x > b) return b;
    return x;
}

struct Ray {
    vec3 origin;
    vec3 direction;
};
vec3 at(Ray r, float t) {
    return r.origin + t * r.direction;
}

struct Camera
{
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
};
// returns a camera with all the settings
Camera newCamera(float width, float height)
{
    Camera camera;

    float aspect_ratio = width / height;
    float viewport_height = 2.0;
    float viewport_width = aspect_ratio * viewport_height;
    float focal_length = 1.0;

    camera.origin = vec3(0.0, 0.0, 0.0);
    camera.horizontal = vec3(viewport_width, 0.0, 0.0);
    camera.vertical = vec3(0.0, viewport_height, 0.0);
    camera.lower_left_corner = camera.origin - camera.horizontal / 2 - camera.vertical / 2 - vec3(0.0, 0.0, focal_length);

    return camera; 
}

Ray sendRay(Camera cam, float u, float v)
{
    return Ray(cam.origin, cam.lower_left_corner + u*cam.horizontal + v*cam.vertical - cam.origin);
}

struct Sphere {
    vec3 center;
    float radius;
};

struct intersectionInfo{
    vec3 pos;
    vec3 normal;
    float t;
};

bool hit_sphere(Sphere sphere, Ray r, float t_min, float t_max, out intersectionInfo info) {
    vec3 oc = r.origin - sphere.center;
    float a = dot(r.direction, r.direction);
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - a * c;

    if (discriminant > 0) {
        float temp = (-b - sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            info.t = temp;
            info.pos = at(r, temp);
            info.normal = normalize(info.pos - sphere.center);
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            info.t = temp;
            info.pos = at(r, temp);
            info.normal = info.pos - sphere.center / sphere.radius;
            return true;
        }
    }
    return false;
}

bool hit(Ray r, Sphere world[2], float t_min, float t_max, out intersectionInfo info) {
    intersectionInfo temp;
    bool hit_anything = false;
    float closest_so_far = t_max;
    for (int i = 0; i < 2; i++) {
        if (hit_sphere(world[i], r, t_min, closest_so_far, temp)) {
            hit_anything = true;
            closest_so_far = temp.t;
            info = temp;
        }
    }
    return hit_anything;
}


vec4 skyColor(Ray r)
{
    vec3 unitDirection = normalize(r.direction);
    float t = 0.5 * (unitDirection.y + 1.0);
    return mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.5, 0.7, 1.0, 1.0), t);
}

vec4 rayColor(const Ray r, Sphere world[2], int depth)
{
    intersectionInfo info;
    if(hit(r, world, 0, 99999.9, info))
    {
        vec3 color = 0.5*(info.normal + 1.0);
        return vec4(color, 1.0);
    }
    return skyColor(r);
}

void writeColor(vec4 color, int x, int y, int samplesPerPixel)
{
    float r = color.x;
    float g = color.y;
    float b = color.z;

    float scale = 1.0 / float(samplesPerPixel);
    r *= scale;
    g *= scale;
    b *= scale;

    imageStore(screen, ivec2(x, y), vec4(clamp(r, 0.0, 0.999), clamp(g, 0.0, 0.999), clamp(b, 0.0, 0.999), 1.0));
}


void main()
{
    ivec2 screen_size = imageSize(screen);
    ivec2 screen_pos = ivec2(gl_GlobalInvocationID.xy);

    float aspect = float(screen_size.x) / float(screen_size.y);
    float viewport_height = 2.0;
    float viewport_width = aspect * viewport_height;
    float focal_length = 1.0;
    int samplesPerPixel = 10;

    // camera
    vec3 origin = vec3(0, 0, 0);
    vec3 horizontal = vec3(viewport_width, 0, 0);
    vec3 vertical = vec3(0, viewport_height, 0);
    vec3 lower_left_corner = origin - horizontal / 2.0 - vertical / 2.0 - vec3(0, 0, focal_length);

    Sphere world[2];
    world[0] = Sphere(vec3(0, 0, -1), 0.5);
    world[1] = Sphere(vec3(0, -100.5, -1), 100);

    Camera cam = newCamera(screen_size.x, screen_size.y);   
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
    for(int i = 0; i < samplesPerPixel; ++i)
    {
        float u = float(screen_pos.x) / float(screen_size.x - 1);
        float v = float(screen_pos.y) / float(screen_size.y - 1);
        Ray r = sendRay(cam, u, v);
        color += rayColor(r, world, 10);
    }
    writeColor(color, screen_pos.x, screen_pos.y, samplesPerPixel);
}