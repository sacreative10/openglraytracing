#version 460 core
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

#define INF 1e30


struct Ray {
    vec3 origin;
    vec3 direction;
};
vec3 at(Ray r, float t) {
    return r.origin + t * r.direction;
}

struct Sphere {
    vec3 center;
    float radius;
};

struct intersectionInfo{
    vec3 pos;
    vec3 normal;
    float t;
};

bool hit_sphere(Sphere sphere, Ray r, float t_min, float t_max, out intersectionInfo info) {
    vec3 oc = r.origin - sphere.center;
    float a = dot(r.direction, r.direction);
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - a * c;

    if (discriminant > 0) {
        float temp = (-b - sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            info.t = temp;
            info.pos = at(r, temp);
            info.normal = normalize(info.pos - sphere.center);
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            info.t = temp;
            info.pos = at(r, temp);
            info.normal = info.pos - sphere.center / sphere.radius;
            return true;
        }
    }
    return false;
}

bool hit(Ray r, Sphere world[2], float t_min, float t_max, out intersectionInfo info) {
    intersectionInfo temp;
    bool hit_anything = false;
    float closest_so_far = t_max;
    for (int i = 0; i < 2; i++) {
        if (hit_sphere(world[i], r, t_min, closest_so_far, temp)) {
            hit_anything = true;
            closest_so_far = temp.t;
            info = temp;
        }
    }
    return hit_anything;
}

vec4 rayColor(const Ray r, Sphere world[2])
{
    intersectionInfo info;
    if(hit(r, world, 0, 9999999.9, info))
    {
        vec3 color = 0.5 * (info.normal + 1.0);
        return vec4(color, 1.0);
    }
    vec3 unitDirection = normalize(r.direction);
    float t = 0.5 * (unitDirection.y + 1.0);
    return mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.5, 0.7, 1.0, 1.0), t);
}



void main()
{
    ivec2 screen_size = imageSize(screen);
    ivec2 screen_pos = ivec2(gl_GlobalInvocationID.xy);

    float aspect = float(screen_size.x) / float(screen_size.y);
    float viewport_height = 2.0;
    float viewport_width = aspect * viewport_height;
    float focal_length = 1.0;

    // camera
    vec3 origin = vec3(0, 0, 0);
    vec3 horizontal = vec3(viewport_width, 0, 0);
    vec3 vertical = vec3(0, viewport_height, 0);
    vec3 lower_left_corner = origin - horizontal / 2.0 - vertical / 2.0 - vec3(0, 0, focal_length);

    Sphere world[2];
    world[0] = Sphere(vec3(0, 0, -1), 0.5);
    world[1] = Sphere(vec3(0, -100.5, -1), 100);

    float u = float(screen_pos.x) / float(screen_size.x - 1);
    float v = float(screen_pos.y) / float(screen_size.y - 1);
    vec3 direction = lower_left_corner + u * horizontal + v * vertical;
    Ray r = Ray(origin, direction);


    imageStore(screen, screen_pos, rayColor(r, world)); 

}